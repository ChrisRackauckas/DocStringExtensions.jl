{
    "docs": [
        {
            "location": "/", 
            "text": "DocStringExtensions\n\n\n#\n\n\nDocStringExtensions\n \n \nModule\n.\n\n\nExtensions for the Julia docsystem.\n\n\nIntroduction\n\n\nThis package provides a collection of useful extensions for Julia's built-in docsystem. These are features that are still regarded as \"experimental\" and not yet mature enough to be considered for inclusion in \nBase\n, or that have sufficiently niche use cases that including them with the default Julia installation is not seen as valuable enough at this time.\n\n\nCurrently \nDocStringExtensions.jl\n exports a collection of so-called \"abbreviations\", which can be used to add useful automatically generated information to docstrings. These include information such as:\n\n\n\n\nsimplified method signatures;\n\n\ndocumentation for the individual fields of composite types;\n\n\nimport and export lists for modules;\n\n\nand source-linked lists of methods applicable to a particular docstring.\n\n\n\n\nUsers are most welcome to suggest additional abbreviation ideas, or implement and submit them themselves. Julia's strong support for program introspection makes this a reasonably straight forward process.\n\n\nDetails of the currently available abbreviations can be viewed in their individual docstrings listed below in the \"Exports\" section.\n\n\nExamples\n\n\nIn simple terms an abbreviation can be used by simply interpolating it into a suitable docstring. For example:\n\n\nusing\n \nDocStringExtensions\n\n\n\n\n\nA short summary of `func`...\n\n\n\n$(SIGNATURES)\n\n\n\nwhere `x` and `y` should both be positive.\n\n\n\n# Details\n\n\n\nSome details about `func`...\n\n\n\n\nfunc\n(\nx\n,\n \ny\n)\n \n=\n \nx\n \n+\n \ny\n\n\n\n\n\n\n$(SIGNATURES)\n will be replaced in the above docstring with\n\n\n# Signatures\n\n```julia\nfunc(x, y)\n```\n\n\n\n\n\nThe resulting generated content can be viewed via Julia's \n?\n mode or, if \nDocumenter.jl\n is set up, the generated external documentation.\n\n\nThe advantage of using \nSIGNATURES\n (and other abbreviations) is that docstrings are less likely to become out-of-sync with the surrounding code. Note though that references to the argument names \nx\n and \ny\n that have been manually embedded within the docstring are, of course, not updated automatically.\n\n\nExports\n\n\n\n\nEXPORTS\n\n\nFIELDS\n\n\nIMPORTS\n\n\nMETHODLIST\n\n\nSIGNATURES\n\n\n\n\nImports\n\n\n\n\nBase\n\n\nCompat\n\n\nCore\n\n\n\n\n\n\nNote\n\n\nThis package is installable on Julia 0.4, but does not provide any features. Abbreviations can still be interpolated into docstrings but will expand to an empty string rather than the expected auto-generated content that it would on Julia 0.5 and above.\n\n\nThis allows the package to be added as a dependancy for packages that still support Julia 0.4 to allow them to begin using abbreviations without needing to conditionally import this pacakage.\n\n\n\n\nsource\n\n\n\n\nIndex\n\n\n\n\nDocStringExtensions.EXPORTS\n\n\nDocStringExtensions.FIELDS\n\n\nDocStringExtensions.IMPORTS\n\n\nDocStringExtensions.METHODLIST\n\n\nDocStringExtensions.SIGNATURES\n\n\nDocStringExtensions.Abbreviation\n\n\nDocStringExtensions.MethodList\n\n\nDocStringExtensions.MethodSignatures\n\n\nDocStringExtensions.ModuleExports\n\n\nDocStringExtensions.ModuleImports\n\n\nDocStringExtensions.TypeFields\n\n\nDocStringExtensions.alltypesigs\n\n\nDocStringExtensions.arguments\n\n\nDocStringExtensions.cleanpath\n\n\nDocStringExtensions.format\n\n\nDocStringExtensions.getmethods\n\n\nDocStringExtensions.getmethods!\n\n\nDocStringExtensions.groupby\n\n\nDocStringExtensions.groupby!\n\n\nDocStringExtensions.keywords\n\n\nDocStringExtensions.methodgroups\n\n\nDocStringExtensions.parsedocs\n\n\nDocStringExtensions.printmethod\n\n\nDocStringExtensions.url\n\n\n\n\n\n\nReference\n\n\n#\n\n\nDocStringExtensions.EXPORTS\n \n \nConstant\n.\n\n\nAn \nAbbreviation\n to include all the exported names of a module is a sorted list of \nDocumenter.jl\n-style \n@ref\n links.\n\n\n\n\nNote\n\n\nThe names are sorted alphabetically and ignore leading \n@\n characters so that macros are \nnot\n sorted before other names.\n\n\n\n\nExamples\n\n\nThe markdown text generated by the \nEXPORTS\n abbreviation looks similar to the following:\n\n\n# Exports\n\n  - [`bar`](@ref)\n  - [`@baz`](@ref)\n  - [`foo`](@ref)\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.FIELDS\n \n \nConstant\n.\n\n\nAn \nAbbreviation\n to include the names of the fields of a type as well as any documentation that may be attached to the fields.\n\n\nExamples\n\n\nThe generated markdown text should look similar to to following example where a type has three fields (\nx\n, \ny\n, and \nz\n) and the last two have documentation attached.\n\n\n# Fields\n\n  - `x`\n\n  - `y`\n\n    Unlike the `x` field this field has been documented.\n\n  - `z`\n\n    Another documented field.\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.IMPORTS\n \n \nConstant\n.\n\n\nAn \nAbbreviation\n to include all the imported modules in a sorted list.\n\n\nExamples\n\n\nThe markdown text generated by the \nIMPORTS\n abbreviation looks similar to the following:\n\n\n# Imports\n\n  - Foo\n  - Bar\n  - Baz\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.METHODLIST\n \n \nConstant\n.\n\n\nAn \nAbbreviation\n for including a list of all the methods that match a documented \nMethod\n, \nFunction\n, or \nDataType\n within the current module.\n\n\nExamples\n\n\nThe generated markdown text will look similar to the following example where a function \nf\n defines two different methods (one that takes a number, and the other a string):\n\n\n# Methods\n\n```julia\nf(num)\n```\n\ndefined at [`\npath\n:\nline\n`](\ngithub-url\n).\n\n```julia\nf(str)\n```\n\ndefined at [`\npath\n:\nline\n`](\ngithub-url\n).\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.SIGNATURES\n \n \nConstant\n.\n\n\nAn \nAbbreviation\n for including a simplified representation of all the method signatures that match the given docstring. See \nprintmethod\n for details on the simplifications that are applied.\n\n\nExamples\n\n\nThe generated markdown text will look similar to the following example where a function \nf\n defines method taking two positional arguments, \nx\n and \ny\n, and two keywords, \na\n and the \nb\n.\n\n\n# Signatures\n\n```julia\nf(x, y; a, b...)\n```\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.alltypesigs\n \n \nMethod\n.\n\n\nSignatures\n\n\nalltypesigs\n(\nsig\n)\n\n\n\n\n\n\nReturns a \nSimpleVector\n of the \nTuple\n types contained in \nsig\n.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.arguments\n \n \nMethod\n.\n\n\nReturns the list of arguments for a particular method \nm\n.\n\n\nSignatures\n\n\narguments\n(\nm\n)\n\n\n\n\n\n\nExamples\n\n\nf\n(\nx\n;\n \na\n \n=\n \n1\n,\n \nb\n...\n)\n \n=\n \nx\n\n\nargs\n \n=\n \narguments\n(\nfirst\n(\nmethods\n(\nf\n)))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.cleanpath\n \n \nMethod\n.\n\n\nSignatures\n\n\ncleanpath\n(\npath\n)\n\n\n\n\n\n\nRemove the \nPkg.dir\n part of a file \npath\n if it exists.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.format\n \n \nMethod\n.\n\n\nExpand the \nAbbreviation\n \nabbr\n in the context of the \nDocStr\n \ndoc\n and write the resulting markdown-formatted text to the \nIOBuffer\n \nbuf\n.\n\n\nSignatures\n\n\nformat\n(\nabbr\n,\n \nbuf\n,\n \ndoc\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.getmethods!\n \n \nMethod\n.\n\n\nSignatures\n\n\ngetmethods!\n(\nresults\n,\n \nf\n,\n \nsig\n)\n\n\n\n\n\n\nA helper method for \ngetmethods\n that collects methods in \nresults\n.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.getmethods\n \n \nMethod\n.\n\n\nCollect and return all methods of function \nf\n matching signature \nsig\n.\n\n\nSignatures\n\n\ngetmethods\n(\nf\n,\n \nsig\n)\n\n\n\n\n\n\nThis is similar to \nmethods(f, sig)\n, but handles type signatures found in \nDocStr\n objects more consistently that \nmethods\n.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.groupby!\n \n \nMethod\n.\n\n\nSignatures\n\n\ngroupby!\n(\nf\n,\n \ngroups\n,\n \ndata\n)\n\n\n\n\n\n\nA helper method for \ngroupby\n that uses a pre-allocated \ngroups\n \nDict\n.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.groupby\n \n \nMethod\n.\n\n\nGroup \ndata\n using function \nf\n where key type is specified by \nK\n and group type by \nV\n.\n\n\nSignatures\n\n\ngroupby\n(\nf\n,\n \nK\n,\n \nV\n,\n \ndata\n)\n\n\n\n\n\n\nThe function \nf\n takes a single argument, an element of \ndata\n, and should return a 2-tuple of \n(computed_key, element)\n. See the example below for details.\n\n\nExamples\n\n\ngroupby\n(\nInt\n,\n \nVector\n{\nInt\n},\n \ncollect\n(\n1\n:\n10\n))\n \ndo\n \nnum\n\n    \nmod\n(\nnum\n,\n \n3\n),\n \nnum\n\n\nend\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.keywords\n \n \nMethod\n.\n\n\nReturns the list of keywords for a particular method \nm\n of a function \nfunc\n.\n\n\nSignatures\n\n\nkeywords\n(\nfunc\n,\n \nm\n)\n\n\n\n\n\n\nExamples\n\n\nf\n(\nx\n;\n \na\n \n=\n \n1\n,\n \nb\n...\n)\n \n=\n \nx\n\n\nkws\n \n=\n \nkeywords\n(\nf\n,\n \nfirst\n(\nmethods\n(\nf\n)))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.methodgroups\n \n \nMethod\n.\n\n\nGroup all methods of function \nfunc\n with type signatures \ntypesig\n in module \nmodname\n.\n\n\nSignatures\n\n\nmethodgroups\n(\nfunc\n,\n \ntypesig\n,\n \nmodname\n;\n \nexact\n)\n\n\n\n\n\n\nKeyword argument \nexact = true\n matches signatures \"exactly\" with \n==\n rather than \n:\n.\n\n\nExamples\n\n\ngroups\n \n=\n \nmethodgroups\n(\nf\n,\n \nUnion\n{\nTuple\n{\nAny\n},\n \nTuple\n{\nAny\n,\n \nInteger\n}},\n \nMain\n;\n \nexact\n \n=\n \nfalse\n)\n\n\n\n\n\n\nMethods\n\n\nmethodgroups\n(\nfunc\n,\n \ntypesig\n,\n \nmodname\n;\n \nexact\n)\n\n\n\n\n\n\ndefined at \nDocStringExtensions/src/utilities.jl:27\n.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.parsedocs\n \n \nMethod\n.\n\n\nParse all docstrings defined within a module \nmod\n.\n\n\nSignatures\n\n\nparsedocs\n(\nmod\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.printmethod\n \n \nMethod\n.\n\n\nPrint a simplified representation of a method signature to \nbuffer\n.\n\n\nSignatures\n\n\nprintmethod\n(\nbuffer\n,\n \nbinding\n,\n \nfunc\n,\n \nmethod\n)\n\n\n\n\n\n\nSimplifications include:\n\n\n\n\nno \nTypeVar\ns;\n\n\nno types;\n\n\nno keyword default values;\n\n\n?\n printed where \n#unused#\n arguments are found.\n\n\n\n\nExamples\n\n\nf\n(\nx\n;\n \na\n \n=\n \n1\n,\n \nb\n...\n)\n \n=\n \nx\n\n\nsig\n \n=\n \nprintmethod\n(\nDocs\n.\nBinding\n(\nMain\n,\n \n:\nf\n),\n \nf\n,\n \nfirst\n(\nmethods\n(\nf\n)))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.url\n \n \nMethod\n.\n\n\nGet the URL (file and line number) where a method \nm\n is defined.\n\n\nSignatures\n\n\nurl\n(\nm\n)\n\n\n\n\n\n\nNote that this is based on the implementation of \nBase.url\n, but handles URLs correctly on TravisCI as well.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.Abbreviation\n \n \nType\n.\n\n\nAbbreviation objects are used to automatically generate context-dependant markdown content within documentation strings. Objects of this type interpolated into docstrings will be expanded automatically before parsing the text to markdown.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.MethodList\n \n \nType\n.\n\n\nThe singleton type for \nMETHODLIST\n abbreviations.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.MethodSignatures\n \n \nType\n.\n\n\nThe singleton type for \nSIGNATURES\n abbreviations.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.ModuleExports\n \n \nType\n.\n\n\nThe singleton type for \nEXPORTS\n abbreviations.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.ModuleImports\n \n \nType\n.\n\n\nThe singleton type for \nIMPORTS\n abbreviations.\n\n\nsource\n\n\n#\n\n\nDocStringExtensions.TypeFields\n \n \nType\n.\n\n\nThe singleton type for \nFIELDS\n abbreviations.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#docstringextensions", 
            "text": "#  DocStringExtensions     Module .  Extensions for the Julia docsystem.  Introduction  This package provides a collection of useful extensions for Julia's built-in docsystem. These are features that are still regarded as \"experimental\" and not yet mature enough to be considered for inclusion in  Base , or that have sufficiently niche use cases that including them with the default Julia installation is not seen as valuable enough at this time.  Currently  DocStringExtensions.jl  exports a collection of so-called \"abbreviations\", which can be used to add useful automatically generated information to docstrings. These include information such as:   simplified method signatures;  documentation for the individual fields of composite types;  import and export lists for modules;  and source-linked lists of methods applicable to a particular docstring.   Users are most welcome to suggest additional abbreviation ideas, or implement and submit them themselves. Julia's strong support for program introspection makes this a reasonably straight forward process.  Details of the currently available abbreviations can be viewed in their individual docstrings listed below in the \"Exports\" section.  Examples  In simple terms an abbreviation can be used by simply interpolating it into a suitable docstring. For example:  using   DocStringExtensions   A short summary of `func`...  $(SIGNATURES)  where `x` and `y` should both be positive.  # Details  Some details about `func`...   func ( x ,   y )   =   x   +   y   $(SIGNATURES)  will be replaced in the above docstring with  # Signatures\n\n```julia\nfunc(x, y)\n```  The resulting generated content can be viewed via Julia's  ?  mode or, if  Documenter.jl  is set up, the generated external documentation.  The advantage of using  SIGNATURES  (and other abbreviations) is that docstrings are less likely to become out-of-sync with the surrounding code. Note though that references to the argument names  x  and  y  that have been manually embedded within the docstring are, of course, not updated automatically.  Exports   EXPORTS  FIELDS  IMPORTS  METHODLIST  SIGNATURES   Imports   Base  Compat  Core    Note  This package is installable on Julia 0.4, but does not provide any features. Abbreviations can still be interpolated into docstrings but will expand to an empty string rather than the expected auto-generated content that it would on Julia 0.5 and above.  This allows the package to be added as a dependancy for packages that still support Julia 0.4 to allow them to begin using abbreviations without needing to conditionally import this pacakage.   source", 
            "title": "DocStringExtensions"
        }, 
        {
            "location": "/#index", 
            "text": "DocStringExtensions.EXPORTS  DocStringExtensions.FIELDS  DocStringExtensions.IMPORTS  DocStringExtensions.METHODLIST  DocStringExtensions.SIGNATURES  DocStringExtensions.Abbreviation  DocStringExtensions.MethodList  DocStringExtensions.MethodSignatures  DocStringExtensions.ModuleExports  DocStringExtensions.ModuleImports  DocStringExtensions.TypeFields  DocStringExtensions.alltypesigs  DocStringExtensions.arguments  DocStringExtensions.cleanpath  DocStringExtensions.format  DocStringExtensions.getmethods  DocStringExtensions.getmethods!  DocStringExtensions.groupby  DocStringExtensions.groupby!  DocStringExtensions.keywords  DocStringExtensions.methodgroups  DocStringExtensions.parsedocs  DocStringExtensions.printmethod  DocStringExtensions.url", 
            "title": "Index"
        }, 
        {
            "location": "/#reference", 
            "text": "#  DocStringExtensions.EXPORTS     Constant .  An  Abbreviation  to include all the exported names of a module is a sorted list of  Documenter.jl -style  @ref  links.   Note  The names are sorted alphabetically and ignore leading  @  characters so that macros are  not  sorted before other names.   Examples  The markdown text generated by the  EXPORTS  abbreviation looks similar to the following:  # Exports\n\n  - [`bar`](@ref)\n  - [`@baz`](@ref)\n  - [`foo`](@ref)  source  #  DocStringExtensions.FIELDS     Constant .  An  Abbreviation  to include the names of the fields of a type as well as any documentation that may be attached to the fields.  Examples  The generated markdown text should look similar to to following example where a type has three fields ( x ,  y , and  z ) and the last two have documentation attached.  # Fields\n\n  - `x`\n\n  - `y`\n\n    Unlike the `x` field this field has been documented.\n\n  - `z`\n\n    Another documented field.  source  #  DocStringExtensions.IMPORTS     Constant .  An  Abbreviation  to include all the imported modules in a sorted list.  Examples  The markdown text generated by the  IMPORTS  abbreviation looks similar to the following:  # Imports\n\n  - Foo\n  - Bar\n  - Baz  source  #  DocStringExtensions.METHODLIST     Constant .  An  Abbreviation  for including a list of all the methods that match a documented  Method ,  Function , or  DataType  within the current module.  Examples  The generated markdown text will look similar to the following example where a function  f  defines two different methods (one that takes a number, and the other a string):  # Methods\n\n```julia\nf(num)\n```\n\ndefined at [` path : line `]( github-url ).\n\n```julia\nf(str)\n```\n\ndefined at [` path : line `]( github-url ).  source  #  DocStringExtensions.SIGNATURES     Constant .  An  Abbreviation  for including a simplified representation of all the method signatures that match the given docstring. See  printmethod  for details on the simplifications that are applied.  Examples  The generated markdown text will look similar to the following example where a function  f  defines method taking two positional arguments,  x  and  y , and two keywords,  a  and the  b .  # Signatures\n\n```julia\nf(x, y; a, b...)\n```  source  #  DocStringExtensions.alltypesigs     Method .  Signatures  alltypesigs ( sig )   Returns a  SimpleVector  of the  Tuple  types contained in  sig .  source  #  DocStringExtensions.arguments     Method .  Returns the list of arguments for a particular method  m .  Signatures  arguments ( m )   Examples  f ( x ;   a   =   1 ,   b ... )   =   x  args   =   arguments ( first ( methods ( f )))   source  #  DocStringExtensions.cleanpath     Method .  Signatures  cleanpath ( path )   Remove the  Pkg.dir  part of a file  path  if it exists.  source  #  DocStringExtensions.format     Method .  Expand the  Abbreviation   abbr  in the context of the  DocStr   doc  and write the resulting markdown-formatted text to the  IOBuffer   buf .  Signatures  format ( abbr ,   buf ,   doc )   source  #  DocStringExtensions.getmethods!     Method .  Signatures  getmethods! ( results ,   f ,   sig )   A helper method for  getmethods  that collects methods in  results .  source  #  DocStringExtensions.getmethods     Method .  Collect and return all methods of function  f  matching signature  sig .  Signatures  getmethods ( f ,   sig )   This is similar to  methods(f, sig) , but handles type signatures found in  DocStr  objects more consistently that  methods .  source  #  DocStringExtensions.groupby!     Method .  Signatures  groupby! ( f ,   groups ,   data )   A helper method for  groupby  that uses a pre-allocated  groups   Dict .  source  #  DocStringExtensions.groupby     Method .  Group  data  using function  f  where key type is specified by  K  and group type by  V .  Signatures  groupby ( f ,   K ,   V ,   data )   The function  f  takes a single argument, an element of  data , and should return a 2-tuple of  (computed_key, element) . See the example below for details.  Examples  groupby ( Int ,   Vector { Int },   collect ( 1 : 10 ))   do   num \n     mod ( num ,   3 ),   num  end   source  #  DocStringExtensions.keywords     Method .  Returns the list of keywords for a particular method  m  of a function  func .  Signatures  keywords ( func ,   m )   Examples  f ( x ;   a   =   1 ,   b ... )   =   x  kws   =   keywords ( f ,   first ( methods ( f )))   source  #  DocStringExtensions.methodgroups     Method .  Group all methods of function  func  with type signatures  typesig  in module  modname .  Signatures  methodgroups ( func ,   typesig ,   modname ;   exact )   Keyword argument  exact = true  matches signatures \"exactly\" with  ==  rather than  : .  Examples  groups   =   methodgroups ( f ,   Union { Tuple { Any },   Tuple { Any ,   Integer }},   Main ;   exact   =   false )   Methods  methodgroups ( func ,   typesig ,   modname ;   exact )   defined at  DocStringExtensions/src/utilities.jl:27 .  source  #  DocStringExtensions.parsedocs     Method .  Parse all docstrings defined within a module  mod .  Signatures  parsedocs ( mod )   source  #  DocStringExtensions.printmethod     Method .  Print a simplified representation of a method signature to  buffer .  Signatures  printmethod ( buffer ,   binding ,   func ,   method )   Simplifications include:   no  TypeVar s;  no types;  no keyword default values;  ?  printed where  #unused#  arguments are found.   Examples  f ( x ;   a   =   1 ,   b ... )   =   x  sig   =   printmethod ( Docs . Binding ( Main ,   : f ),   f ,   first ( methods ( f )))   source  #  DocStringExtensions.url     Method .  Get the URL (file and line number) where a method  m  is defined.  Signatures  url ( m )   Note that this is based on the implementation of  Base.url , but handles URLs correctly on TravisCI as well.  source  #  DocStringExtensions.Abbreviation     Type .  Abbreviation objects are used to automatically generate context-dependant markdown content within documentation strings. Objects of this type interpolated into docstrings will be expanded automatically before parsing the text to markdown.  source  #  DocStringExtensions.MethodList     Type .  The singleton type for  METHODLIST  abbreviations.  source  #  DocStringExtensions.MethodSignatures     Type .  The singleton type for  SIGNATURES  abbreviations.  source  #  DocStringExtensions.ModuleExports     Type .  The singleton type for  EXPORTS  abbreviations.  source  #  DocStringExtensions.ModuleImports     Type .  The singleton type for  IMPORTS  abbreviations.  source  #  DocStringExtensions.TypeFields     Type .  The singleton type for  FIELDS  abbreviations.  source", 
            "title": "Reference"
        }
    ]
}